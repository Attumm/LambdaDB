package main

import (
	"log"
	"sort"
	"strconv"
	"strings"
	"sync"

	"github.com/Workiva/go-datastructures/bitarray"
)

type registerGroupByFunc map[string]func(*Item) string
type registerGettersMap map[string]func(*Item) string
type registerReduce map[string]func(Items) map[string]string

type registerBitArray map[string]func(s string) (bitarray.BitArray, error)

type fieldIdxMap map[string]uint16
type fieldMapIdx map[uint16]string
type fieldItemsMap map[uint16]bitarray.BitArray

// Column maps.
// Store for each non distinct/repeated column
// unit16 -> string map and
// string -> unit16 map
// track count of distinct values

{{shrinkVars}}

/*
var {columnname}Tracker uint16
var {columnname}IdxMap fieldIdxMap
var {columnname} fieldMapIdx
var {columnname}Items fieldItemmap
*/

// item map lock
var lock = sync.RWMutex{}

// bitArray Lock
var balock = sync.RWMutex{}

func init() {

	{{initRepeatColumns}}

	/*
	labelscoredefinitiefTracker = 0
	labelscoredefinitiefIdxMap = make(fieldIdxMap)
	labelscoredefinitief = make(fieldMapIdx)
	*/
}

{{itemStructs}}


type ItemIn struct {

{{columnsItemIn}}

}

type ItemOut struct {

{{columnsItemOut}}

}


type Item struct {

	Label                int  // internal index in ITEMS
{{columnsItem}}

}


// Shrink create smaller Item using uint16
func (i ItemIn) Shrink(label int) Item {

	lock.Lock()
	defer lock.Unlock()

{{shrinkItems}}

	return Item{

		label,

{{shrinkItemFields}}

	}
}

// Store selected columns in byte array
func (i Item) StoreBitArrayColumns() {

	balock.Lock()
	defer balock.Unlock()

	lock.RLock()
	defer lock.RUnlock()

	/*

	var ba = birarray.BitArray
	var ok = error

	// Column Buurtcode has byte arrays for
	ba, ok = BuurtcodeItems[i.Buurtcode]
	if !ok {
		ba = bitarray.NewSparseBitArray()
		BuurtcodeItems[i.Buurtcode] = ba
	}

	ba.SetBit(uint64(i.Label))

	TODO ADD BIT-ARRAY COLUMNS.
	*/

}

func (i Item) Serialize() ItemOut {

	lock.RLock()
	defer lock.RUnlock()

	return ItemOut{

{{expandItemFields}}

	}
}

func (i ItemIn) Columns() []string {
	return []string{

{{inColumns}}

	}
}

func (i ItemOut) Columns() []string {
	return []string{

{{outColumns}}

	}
}


func (i Item) Row() []string {

	lock.RLock()
	defer lock.RUnlock()

	return []string{

{{expandItemFields}}

	}
}

func (i Item) GetIndex()string{
	return Getters{{indexcolumn}}(&i)
}


func (i Item) GetGeometry() string {
	return {{geometryGetter}}
}

{{columnFilters}}

/*
// contain filters
func FilterEkeyContains(i *Item, s string) bool {
	return strings.Contains(i.Ekey, s)
}


// startswith filters
func FilterEkeyStartsWith(i *Item, s string) bool {
	return strings.HasPrefix(i.Ekey, s)
}


// match filters
func FilterEkeyMatch(i *Item, s string) bool {
	return i.Ekey == s
}

// getters
func GettersEkey(i *Item) string {
	return i.Ekey
}
*/

// reduce functions
func reduceCount(items Items) map[string]string {
	result := make(map[string]string)
	result["count"] = strconv.Itoa(len(items))
	return result
}

type GroupedOperations struct {
	Funcs   registerFuncType
	GroupBy registerGroupByFunc
	Getters registerGettersMap
	Reduce  registerReduce
	BitArrays registerBitArray
}

var Operations GroupedOperations

var RegisterFuncMap registerFuncType
var RegisterGroupBy registerGroupByFunc
var RegisterGetters registerGettersMap
var RegisterReduce registerReduce
var RegisterBitArray registerBitArray

// ValidateRegsiters validate exposed columns do match filter names
func validateRegisters() {
	var i = ItemOut{}
	var filters = []string{"match", "contains", "startswith"}
	for _, c := range i.Columns() {
		for _, f := range filters {
			if _, ok := RegisterFuncMap[f+"-"+c]; !ok {
				log.Fatal(c + " is missing in RegisterMap")
			}
		}
	}
}

func init() {

	RegisterFuncMap = make(registerFuncType)
	RegisterGroupBy = make(registerGroupByFunc)
	RegisterGetters = make(registerGettersMap)
	RegisterReduce = make(registerReduce)

	// register search filter.
	//RegisterFuncMap["search"] = 'EDITYOURSELF'
	// example RegisterFuncMap["search"] = FilterEkeyStartsWith

	//RegisterFuncMap["value"] = 'EDITYOURSELF'
	// example RegisterGetters["value"] = GettersEkey

	// register filters

{{registerFilters}}

	validateRegisters()

	/*
	RegisterFuncMap["match-ekey"] = FilterEkeyMatch
	RegisterFuncMap["contains-ekey"] = FilterEkeyContains
	// register startswith filters
	RegisterFuncMap["startswith-ekey"] = FilterEkeyStartsWith
	// register getters
	RegisterGetters["ekey"] = GettersEkey
	// register groupby
	RegisterGroupBy["ekey"] = GettersEkey

	*/

	// register reduce functions
	RegisterReduce["count"] = reduceCount
}

type sortLookup map[string]func(int, int) bool

func createSort(items Items) sortLookup {

	sortFuncs := sortLookup{

		{{sortColumns}}

		/*
		"ekey":  func(i, j int) bool { return items[i].Ekey < items[j].Ekey },
		"-ekey": func(i, j int) bool { return items[i].Ekey > items[j].Ekey },
		*/
	}
	return sortFuncs
}


func sortBy(items Items, sortingL []string) (Items, []string) {

	lock.Lock()
	defer lock.Unlock()

	sortFuncs := createSort(items)

	for _, sortFuncName := range sortingL {
		sortFunc := sortFuncs[sortFuncName]
		sort.Slice(items, sortFunc)
	}

	// TODO must be nicer way
	keys := []string{}
	for key := range sortFuncs {
		keys = append(keys, key)
	}

	return items, keys
}

/*
	model.go define the 'items' to store.
	All columns with getters and setters are defined here.

	ItemIn, represent rows from the Input data
	Item, the compact item stored in memmory
	ItemOut, defines how and which fields are exported out
	of the API. It is possible to ignore input columns

	Repeated values are stored in maps with int numbers
	as keys.  Optionally bitarrays are created for reapeated
	column values to do fast bit-wise filtering.

	A S2 geo index in created for lat, lon values.

	Unique values are stored as-is.

	The generated codes leaves room to create custom
	index functions yourself to create an API with an
	< 1 ms response time for your specific needs.

	This codebase solves: I need to have an API on this
	tabular dataset fast!
*/

package main

import (
	"log"
	"sort"
	"strconv"
	"strings"
	"sync"
	"errors"

	"github.com/Workiva/go-datastructures/bitarray"
)

type registerGroupByFunc map[string]func(*Item) string
type registerGettersMap map[string]func(*Item) string
type registerReduce map[string]func(Items) map[string]string

type registerBitArray map[string]func(s string) (bitarray.BitArray, error)

type fieldIdxMap map[string]uint16
type fieldMapIdx map[uint16]string
type fieldItemsMap map[uint16]bitarray.BitArray

// Column maps.
// Store for each non distinct/repeated column
// unit16 -> string map and
// string -> unit16 map
// track count of distinct values

{{shrinkVars}}

/*
var {columnname}Tracker uint16
var {columnname}IdxMap fieldIdxMap
var {columnname} fieldMapIdx
var {columnname}Items fieldItemmap
*/

// item map lock
var lock = sync.RWMutex{}

// bitArray Lock
var balock = sync.RWMutex{}


func init() {

	{{initRepeatColumns}}

	/*
	labelscoredefinitiefTracker = 0
	labelscoredefinitiefIdxMap = make(fieldIdxMap)
	labelscoredefinitief = make(fieldMapIdx)
	*/
}

{{itemStructs}}


type ItemIn struct {

{{columnsItemIn}}

}

type ItemOut struct {

{{columnsItemOut}}

}


type Item struct {

	Label                int  // internal index in ITEMS
{{columnsItem}}

}

func (i Item) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.Serialize())
}

// Shrink create smaller Item using uint16
func (i ItemIn) Shrink(label int) Item {

	lock.Lock()
	defer lock.Unlock()

{{shrinkItems}}

	return Item{

		label,

{{shrinkItemFields}}

	}
}

// Store selected columns in seperate map[columnvalue]bitarray
// for gast item lookup
func (i Item) StoreBitArrayColumns() {

	balock.Lock()
	defer balock.Unlock()

	lock.RLock()
	defer lock.RUnlock()

        {% if bitArrayStores is defined %}
	var ba bitarray.BitArray
	var ok bool

	{{ bitArrayStores }}

	{% endif %}

	/*
	// Column Buurtcode has byte arrays for
	ba, ok = BuurtcodeItems[i.Buurtcode]
	if !ok {
		ba = bitarray.NewSparseBitArray()
		BuurtcodeItems[i.Buurtcode] = ba
	}
	ba.SetBit(uint64(i.Label))
	*/

}

func (i Item) Serialize() ItemOut {

	lock.RLock()
	defer lock.RUnlock()

	return ItemOut{

{{expandItemFields}}

	}
}

func (i ItemIn) Columns() []string {
	return []string{

{{inColumns}}

	}
}

func (i ItemOut) Columns() []string {
	return []string{

{{outColumns}}

	}
}


func (i Item) Row() []string {

	lock.RLock()
	defer lock.RUnlock()

	return []string{

{{expandItemFields}}

	}
}

func (i Item) GetIndex()string{
	return Getters{{indexcolumn}}(&i)
}


func (i Item) GetGeometry() string {
	return {{geometryGetter}}
}

{{columnFilters}}

/*
// contain filters
func FilterEkeyContains(i *Item, s string) bool {
	return strings.Contains(i.Ekey, s)
}


// startswith filters
func FilterEkeyStartsWith(i *Item, s string) bool {
	return strings.HasPrefix(i.Ekey, s)
}


// match filters
func FilterEkeyMatch(i *Item, s string) bool {
	return i.Ekey == s
}

// getters
func GettersEkey(i *Item) string {
	return i.Ekey
}
*/

// reduce functions
func reduceCount(items Items) map[string]string {
	result := make(map[string]string)
	result["count"] = strconv.Itoa(len(items))
	return result
}

type GroupedOperations struct {
	Funcs   registerFuncType
	GroupBy registerGroupByFunc
	Getters registerGettersMap
	Reduce  registerReduce
	BitArrays registerBitArray
}

var Operations GroupedOperations

var RegisterFuncMap registerFuncType
var RegisterGroupBy registerGroupByFunc
var RegisterGetters registerGettersMap
var RegisterReduce registerReduce
var RegisterBitArray registerBitArray

// ValidateRegsiters validate exposed columns do match filter names
func validateRegisters() error {
	var i = ItemOut{}
	var filters = []string{"match", "contains", "startswith"}
	for _, c := range i.Columns() {
		for _, f := range filters {
			if _, ok := RegisterFuncMap[f+"-"+c]; !ok {
				return errors.New(c + " is missing in RegisterMap")
			}
		}
	}
	return nil
}

{{bitArrayGetters}}


func init() {

	RegisterFuncMap = make(registerFuncType)
	RegisterGroupBy = make(registerGroupByFunc)
	RegisterGetters = make(registerGettersMap)
	RegisterReduce = make(registerReduce)
	RegisterBitArray = make(registerBitArray)

	// register search filter.
	//RegisterFuncMap["search"] = 'EDITYOURSELF'
	// example RegisterFuncMap["search"] = FilterEkeyStartsWith

	//RegisterFuncMap["value"] = 'EDITYOURSELF'
	// example RegisterGetters["value"] = GettersEkey

	// register filters

{{registerFilters}}

	validateRegisters()

	/*
	RegisterFuncMap["match-ekey"] = FilterEkeyMatch
	RegisterFuncMap["contains-ekey"] = FilterEkeyContains
	// register startswith filters
	RegisterFuncMap["startswith-ekey"] = FilterEkeyStartsWith
	// register getters
	RegisterGetters["ekey"] = GettersEkey
	// register groupby
	RegisterGroupBy["ekey"] = GettersEkey

	*/

	// register reduce functions
	RegisterReduce["count"] = reduceCount
}

type sortLookup map[string]func(int, int) bool

func createSort(items Items) sortLookup {

	sortFuncs := sortLookup{

		{{sortColumns}}

		/*
		"ekey":  func(i, j int) bool { return items[i].Ekey < items[j].Ekey },
		"-ekey": func(i, j int) bool { return items[i].Ekey > items[j].Ekey },
		*/
	}
	return sortFuncs
}


func sortBy(items Items, sortingL []string) (Items, []string) {

	lock.Lock()
	defer lock.Unlock()

	sortFuncs := createSort(items)

	for _, sortFuncName := range sortingL {
		sortFunc := sortFuncs[sortFuncName]
		sort.Slice(items, sortFunc)
	}

	// TODO must be nicer way
	keys := []string{}
	for key := range sortFuncs {
		keys = append(keys, key)
	}

	return items, keys
}
